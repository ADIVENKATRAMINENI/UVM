// ================================================================
// WHY CLOCKING BLOCK IS USED
// ================================================================
In SystemVerilog/UVM testbenches, a clocking block is used to synchronize testbench stimulus and sampling with the DUT clock.
Without a clocking block, the testbench and DUT may update or read signals at the exact same simulation time (posedge clk), leading to race conditions:

   - DUT updates outputs on posedge clk
   - DUT samples inputs on posedge clk
   - Testbench may also drive inputs or sample outputs at posedge

This causes unpredictable simulation behavior, because the SystemVerilog scheduler cannot guarantee whether TB or DUT executes first at the same timestamp.


// ================================================================
// WHAT THE CLOCKING BLOCK FIXES
// ================================================================
 A clocking block separates the timing of testbench actions from DUT actions by introducing *skews* (#1step).

  input  #1step → TB samples DUT outputs *after* DUT updates them
  output #1step → TB drives DUT inputs  *after* DUT samples them

This ensures clean ordering:
   1) DUT samples inputs at posedge clk
   2) DUT updates outputs at posedge clk
   3) TB samples DUT outputs (#1step later - safe)
   4) TB drives new inputs for next cycle (#1step after that - safe)

 No race, no delta-cycle conflicts, no nondeterministic behavior.


// ================================================================
// WHY SKEWS ONLY IN TESTBENCH, NOT IN DUT
// ================================================================
The DUT models real hardware: flip-flops update and sample precisely at the active clock edge. A clocking block is a *test-bench-only construct* for simulation scheduling control.
Hardware cannot and should not have delayed behavior.Testbench, however, must avoid driving/sampling at the same time as the DUT, so skews are applied on the TB side only.


// ================================================================
// Why races happen:
// ================================================================
Because BOTH these are scheduled on the SAME event:

always_ff @(posedge clk)    // DUT
initial forever @(posedge clk) // TB via cb

If both DUT and TB try to:
sample inputs
update outputs
drive new inputs

at the same posedge,
SystemVerilog must decide: “Who runs first?”

But there is no deterministic rule. So:
❌ TB might run first
❌ or DUT might run first
❌ it may change between runs
❌ values become unpredictable

Hence → race condition.


// ================================================================
Simple Rules to Remember Forever
// ================================================================
✔ DUT = real hardware
DUT always acts exactly at the clock edge.

✔ TB = simulation logic
TB must NOT act at the exact edge → otherwise race.

✔ Skew enforces ordering
DUT first → TB second

✔ Skew is NOT a time delay
It's a scheduler push to next delta cycle.


// ================================================================
// SUMMARY
// ================================================================
Clocking blocks:
✅ Avoid race conditions between TB & DUT
✅ Ensure deterministic simulation behavior
✅ Align TB reads/writes with DUT clocking
✅ Provide clean sampling and driving order
✅ Are used only in testbenches (never inside DUT)
// ================================================================

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Modports::
1. inside drv modport ,Why NOT use cb.rst_n?

Because clocking block puts skew on signals.
→ but reset must NOT be skewed
→ reset is asynchronous
→ driver must look at raw/reset signal

// ============================================================================
// WHY MODPORTS ARE USED IN THE INTERFACE
// ============================================================================
Modports define *which signals* a UVM component (driver/monitor) is allowed to read or write. This prevents accidental driving or sampling of the wrong signals and 
enforces clean separation between TB components.

Without modports:
 - Driver could access DUT outputs by mistake. 
 - Monitor could accidentally drive DUT inputs.
 - Multiple components could drive the same signal (illegal).
 - Testbench would become hard to maintain and debug.

Modports act as "permission layers" on top of the interface.



// ----------------------------------------------------------------------------
// DRIVER MODPORT:  modport drv (clocking cb, input rst_n);
// ----------------------------------------------------------------------------
The driver gets:
   - The clocking block "cb"     → used for *timing-safe* stimulus driving    
  - The raw reset "rst_n"       → driver can *read* reset state (not drive)

Driver DOES NOT see raw signals like:
   wr_en, rd_en, din, dout, full, empty, almost_full, almost_empty because these are NOT listed in the drv modport.

 Even though the clocking block contains these signals, the modport controls *how* the driver sees them:

   • cb.wr_en, cb.rd_en, cb.din  → driver can drive (they are clocking block outputs)
   • cb.dout, cb.full, cb.empty → visible technically, but *driver must not use them*
                                   (architecturally the driver should NOT read outputs)

UVM rule:
  - The DRIVER generates stimulus only.
  - It must NOT observe/check DUT outputs.
    (that’s the monitor and scoreboard's job)

 The modport ensures the driver uses only:
   - timing-safe drivers via cb
   - reset as a simple input to wait for reset deassertion



// ----------------------------------------------------------------------------
// MONITOR MODPORT: modport mon (input ... all signals ... );
// ----------------------------------------------------------------------------
The monitor is a passive component. It must:
   • observe everything on the interface
   • never drive anything

 Therefore, monitor modport lists ALL signals as 'input':
   wr_en, rd_en, din, dout, full, empty, almost_full, almost_empty, rst_n

 This gives monitor FULL VISIBILITY of DUT behavior while guaranteeing:
   • Monitor CANNOT drive any DUT input.
   • Monitor can only read/record/snoop.
   • Safe for protocol checking, coverage, and scoreboard comparison.



// ----------------------------------------------------------------------------
// HOW DRIVER AND MONITOR ACCESS SIGNALS (VIRTUAL INTERFACE)
// ----------------------------------------------------------------------------
 In the driver class:
     virtual fifo_if.drv vif;
 This means:
   - Driver only sees what the 'drv' modport exposes.
   - Driver interacts with signals ONLY through vif.cb.*
   - Driver cannot directly access vif.wr_en or vif.dout.

In the monitor class:
     virtual fifo_if.mon vif;
 This means:
   - Monitor sees all interface signals as read-only.
   - Monitor reads vif.wr_en, vif.rd_en, vif.din, vif.dout, etc.
   - Monitor cannot drive anything.



// ----------------------------------------------------------------------------
// SUMMARY
// ----------------------------------------------------------------------------
 ✅ Clocking block = timing access layer (safe sample/drive).
 ✅ Modport = permission layer (who can see what).
 ✅ Driver = stimulus generator (drives inputs only).
 ✅ Monitor = observer (reads inputs/outputs, never drives).
 ✅ Virtual interface + modport cleanly connect TB components to interface.
// ============================================================================

