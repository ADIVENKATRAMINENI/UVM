ğŸ“˜ FIFO Functional Coverage â€” Concepts & Explanation

This document explains functional coverage used in UVM for verifying a Synchronous FIFO.
It covers covergroups, coverpoints, bins, crosses, sampling, and why coverage is needed.

ğŸ”¶ 1. What Is Functional Coverage?
Functional coverage answers one question:
â€œDid we test ALL important FIFO scenarios?â€

It does not check correctness (that is the scoreboardâ€™s job).
It checks completeness of testing.

Examples of questions coverage answers:
Did FIFO ever become full or empty?
Did almost_full / almost_empty ever toggle?
Did we attempt reads on empty? Writes on full?
Did we hit simultaneous wr+rd?
Did we hit full bypass (wr=1 & rd=1 & full=1)?


ğŸ”¶ 2. What Is a Covergroup?
A covergroup is a SystemVerilog construct that:
Samples signals at a specified event (usually posedge clk)
Contains coverpoints and crosses
Records scenarios that occur in simulation

Example:
covergroup fifo_cg @(posedge vif.clk);
  // coverpoints
  // crosses
endgroup

The covergroup must be constructed using:
fifo_cg = new();


ğŸ”¶ 3. What Is a Coverpoint?
A coverpoint tracks all values of a single signal or variable.

Example:
coverpoint vif.full;

This creates two automatic bins:
full == 0
full == 1
So you know if FIFO ever actually became full during testing.

Used for:
wr_en activity
rd_en activity
full / empty flag transitions
almost_full / almost_empty behavior


ğŸ”¶ 4. What Are Bins?
A bin is a category of values inside a coverpoint.

Example of user-defined bins:
coverpoint data {
  bins low  = {[0:15]};
  bins mid  = {[16:127]};
  bins high = {[128:255]};
}


Special bins:
Type	Purpose
illegal_bins	flag illegal values
ignore_bins	exclude values from coverage

In FIFO, we rely mostly on automatic bins because all signals are 1-bit.


ğŸ”¶ 5. What Is a Cross?
A cross measures combinations of multiple signals.

Example:
cross vif.wr_en, vif.full;

This shows:
Write attempted when full=0 (legal)
Write attempted when full=1 (illegal or bypass)
No write cases
Crosses are critical for FIFO, because bugs happen in combinations, not in individual signals.


ğŸ”¶ 6. FIFO-Specific Crosses Explained
These crosses are essential for FIFO verification:
âœ” wr_full_x â€” Write vs Full
wr_full_x : cross vif.wr_en, vif.full;

This confirms tests exercised:
normal writes
writes when full=1 (overflow attempt)
write+full cases (bypass cycles also included)
âœ” rd_empty_x â€” Read vs Empty
rd_empty_x : cross vif.rd_en, vif.empty;

Checks:
underflow attempts
legal read behavior
âœ” wr_rd_x â€” Simultaneous Write + Read
wr_rd_x : cross vif.wr_en, vif.rd_en;


Used to prove:
FIFO supports concurrent read/write
pointer behavior during simultaneous ops
âœ” bypass_on_full â€” Full Bypass Detection
bypass_on_full : cross vif.wr_en, vif.rd_en, vif.full;

This is the exact signature of full-bypass:
wr_en = 1
rd_en = 1
full  = 1

If this bin hits â†’ bypass was genuinely tested.
âœ” almost_state_x â€” Almost Flag Sanity
almost_state_x : cross vif.almost_full, vif.almost_empty;

We ensure:
Flags toggle correctly
They never both become 1 simultaneously


ğŸ”¶ 7. How Coverage Samples Signals
Three main ways:
âœ” Clocked Sampling (used here)
covergroup fifo_cg @(posedge vif.clk);

Samples:
wr_en
rd_en
full / empty
almost_full / almost_empty
every clock edge.


ğŸ”¶ 8. How fifo_coverage Fits Into UVM
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   DRIVER   â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   DUT      â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
   raw signals â”‚
               â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  MONITOR   â”‚â”€â”€â”€â”€â”€â”€â–º sends transactions to scoreboard
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
    vif taps   â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ COVERAGE   â”‚â”€â”€â”€â”€â–º measures scenarios (not correctness)
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


Coverage is passive.
It does not compare or check anything.
It simply records signal activity and combinations.

ğŸ”¶ 9. Why Coverage Is Required for FIFO Sign-off

Coverage ensures:
Feature	Verified?
FIFO reaches full	âœ”
FIFO reaches empty	âœ”
Almost flags toggle	âœ”
Underflow attempts happened	âœ”
Overflow attempts happened	âœ”
Simultaneous wr+rd tested	âœ”
Full-bypass exercised	âœ”

Coverage + Scoreboard + Sequences = Complete Verification
