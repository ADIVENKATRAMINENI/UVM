UART Driver
This file explains the purpose and working of the UART UVM driver used in the UART TX â†’ RX loopback verification project.


ğŸ”¹ What the UART driver does
The uart_driver is responsible for taking transactions (uart_txn) generated by sequences and driving the DUT input pins (tx_start, tx_data) according to the UART protocol timing.

Sequence â†’ Transaction â†’ Driver â†’ DUT (UART TX)

The driver does not generate serial UART waveform. It only delivers the parallel byte and a start pulse to the DUT.
The UART hardware inside the DUT generates the serial bitstream using its baud generator.

ğŸ”¹ High-level data flow in run_phase
1. Get a transaction from the sequencer
2. Wait until the UART is not busy (tx_busy == 0)
3. Put the transaction byte on tx_data
4. Pulse tx_start for exactly one clock cycle
5. Wait for idle_cycles (optional spacing between frames)
6. Notify sequencer that transaction is completed


ğŸ”¹ Why we wait for tx_busy
UART sets tx_busy = 1 while it is transmitting:
Start bit â†’ 8 data bits â†’ Stop bit

The driver must not send the next frame until the current one is fully transmitted.
This is why we use:
while (vif.cb.tx_busy) @(posedge vif.cb);
This protects the protocol from overlapping frames.


ğŸ”¹ Why we pulse tx_start for exactly one clock
The UART samples tx_start and tx_data only on one rising clock edge to latch the byte.
After that, the hardware internally sends the serial waveform.

Correct timing:
tx_start = 1 for 1 clock â†’ UART latches byte
tx_start = 0 afterward â†’ avoids retriggering


ğŸ”¹ Role of idle_cycles
idle_cycles is not the time UART takes to transmit the bits. UART transmission time is handled by the DUT using the baud generator.
idle_cycles is an intentional waiting period added by the testbench to simulate different traffic patterns:

The driver uses the same mechanism for all sequences; only the sequence controls the spacing.

ğŸ”¹ Big picture timing
Driver:   tx_start  â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€ ...
                     â”‚    â”‚                            â”‚    â”‚
                     â””â”€â”€â”€â”€â”˜                            â””â”€â”€â”€â”€â”˜
                     â†‘ latch byte                      â†‘ latch next byte

UART:    [start][d0][d1][d2][d3][d4][d5][d6][d7][stop]   [ ... next frame ... ]
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tx_busy = 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


The UART driver delivers a byte and a one-clock tx_start pulse to the DUT, waits until UART finishes transmitting using tx_busy, 
adds optional idle time to model real-world spacing, and then fetches the next transaction â€” enabling safe and flexible high-level stimulus without controlling serial bit timing manually.
