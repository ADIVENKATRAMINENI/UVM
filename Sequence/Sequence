ğŸ§© UVM Day 2 Concepts â€“ Sequences, Parameterization & Handshake

ğŸ§  Concept 1 â€“ Sequence Class (`uvm_sequence`)

A **sequence** creates, randomizes, and sends transactions to the DUT via the **sequencer** and **driver**.
It acts like a *script* controlling the DUTâ€™s stimulus and order of operations.

| Class               | Role        | Purpose                            |
| ------------------- | ----------- | ---------------------------------- |
| `uvm_sequence_item` | Data object | Describes one transaction          |
| `uvm_sequence`      | Controller  | Generates and sends multiple items |


Example

class counter_seq extends uvm_sequence#(counter_item);
  `uvm_object_utils(counter_seq)
  task body();
    repeat (5) begin
      counter_item tr = counter_item::type_id::create("tr");
      start_item(tr);
      assert(tr.randomize());
      finish_item(tr);
    end
  endtask
endclass

-------------------------------------

ğŸ§© Concept 2 â€“ How Sequences Control Stimulus

Step-by-Step Flow

1ï¸âƒ£ Sequence creates a `counter_item` transaction.
2ï¸âƒ£ `start_item(tr)` notifies the sequencer that an item is ready.
3ï¸âƒ£ Sequencer passes it to the driver.
4ï¸âƒ£ Driver drives DUT pins based on transaction data.
5ï¸âƒ£ Sequence repeats the process for multiple transactions.

âœ… **Purpose:** Automate stimulus generation â†’ higher coverage with less code.

--------------------------------------

ğŸ”„ Concept 3 â€“ Parameterized Sequences

UVM allows parameterizing the sequence with the transaction type.

class counter_seq extends uvm_sequence#(counter_item);

This means your sequence is reusable â€” just change the transaction type!

Example of Reuse

class uart_seq extends uvm_sequence#(uart_item);
class spi_seq  extends uvm_sequence#(spi_item);

âœ… The same `body()` flow works for different transaction types.

Benefits

| Benefit        | Description                            |
| -------------- | -------------------------------------- |
| ğŸ” Reusability | Same sequence logic for different DUTs |
| âš™ï¸ Scalability | Easy to extend for new interfaces      |
| ğŸ§© Modularity  | One template serves multiple projects  |

----------------------------------------

ğŸ§  Concept 4 â€“ Difference Between `uvm_do`, `start_item`, and `finish_item`

| Method                                  | Description                                             | Recommended?    |
| --------------------------------------- | ------------------------------------------------------- | --------------- |
| `` `uvm_do(tr) ``                       | Old macro combining create + start + randomize + finish | âŒ Legacy only   |
| `` `uvm_do_with(tr, { constraints }) `` | Legacy shorthand with inline constraints                | âŒ Outdated      |
| `start_item(tr)` / `finish_item(tr)`    | Modern explicit control                                 | âœ… Best practice |

âœ… Tip:
Use `start_item` and `finish_item` for clarity, flexibility, and tool compatibility.

--------------------------------------

ğŸ¤ Concept 5 â€“ Sequencerâ€“Driver Handshake

This is the **communication channel** that transfers transactions from the **sequence** to the **driver**.

#ğŸ§± Inside the Agent
drv.seq_item_port.connect(seqr.seq_item_export);

This connection links the driver and sequencer through TLM ports and exports.

* `seq_item_port` â†’ Driverâ€™s input channel.
* `seq_item_export` â†’ Sequencerâ€™s output channel.

ğŸ§  Inside the Driver

task run_phase(uvm_phase phase);
  counter_item tr;
  forever begin
    seq_item_port.get_next_item(tr); // Receive transaction

    // Drive DUT pins
    vif.reset  = tr.reset;
    vif.enable = tr.enable;

    `uvm_info("DRV",
      $sformatf("Driving: reset=%0b enable=%0b", tr.reset, tr.enable),
      UVM_LOW)

    seq_item_port.item_done(); // Acknowledge completion
  end
endtask

ğŸ” Handshake Flow

| Step | Component | Action                                 |
| ---- | --------- | -------------------------------------- |
| 1ï¸âƒ£  | Sequence  | Randomizes and sends item              |
| 2ï¸âƒ£  | Sequencer | Passes to driver via `seq_item_export` |
| 3ï¸âƒ£  | Driver    | Drives DUT signals                     |
| 4ï¸âƒ£  | Driver    | Calls `item_done()`                    |
| 5ï¸âƒ£  | Sequencer | Enables next item                      |


---------------------------------------------------

ğŸ§© Key Takeaways

* Sequences generate stimulus using `start_item` / `finish_item`.
* Parameterization enables reusability across DUTs.
* The sequencerâ€“driver handshake ensures smooth, ordered communication.

âœ… Together, these form the **core stimulus generation and delivery flow** in UVM.
