# ðŸ§© UVM Layered & Virtual Sequences 


ðŸŒ± 1ï¸âƒ£ Why Do We Need Layered or Nested Sequences?
In basic UVM, one **sequence** runs on **one sequencer** â†’ which drives **one interface** (like a Counter, MUX, or UART).But in **real SoC verification**, 
you often deal with **multiple interfaces**:

* Example: A CPU core uses **APB** for register access, **AXI** for memory, and **UART** for communication.

Now imagine:

* You want to **write data** via APB,
* Then **send that data** through UART.

These two actions belong to **different agents** â†’ they each have their own sequencer, driver, and monitor. Soâ€¦ you need something **above** them to coordinate.
That â€œsomethingâ€ is a **virtual sequence** running on a **virtual sequencer**.

------------------------------------

ðŸ§± 2ï¸âƒ£ What Is a Virtual Sequencer?

| Concept               | Description                                                                                                                                 |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |
| **Regular Sequencer** | Owns one transaction stream for one driver/interface.                                                                                       |
| **Virtual Sequencer** | Holds handles to multiple lower-level sequencers (like APB, AXI, UART). It doesnâ€™t generate transactions directlyâ€”it only coordinates them. |


Example Structure:
virtual_sequencer
 â”œâ”€â”€ apb_sequencer
 â”œâ”€â”€ uart_sequencer
 â””â”€â”€ fifo_sequencer


So the virtual sequencer acts like a **manager** controlling each sub-sequencer.

---

## ðŸ§© 3ï¸âƒ£ What Is a Virtual Sequence?

| Concept              | Description                                                         |
| -------------------- | ------------------------------------------------------------------- |
| **Normal Sequence**  | Generates stimulus for one interface (one sequencer).               |
| **Virtual Sequence** | Runs on a virtual sequencer and coordinates multiple sub-sequences. |

Example: APB + UART Coordination

class top_virtual_sequence extends uvm_sequence;
  `uvm_object_utils(top_virtual_sequence)

  apb_sequence  apb_seq;
  uart_sequence uart_seq;

  virtual task body();
    // Create sub-sequences
    apb_seq  = apb_sequence ::type_id::create("apb_seq");
    uart_seq = uart_sequence::type_id::create("uart_seq");

    `uvm_info("VSEQ", "Starting coordinated operations", UVM_LOW)

    // 1. Write data via APB
    apb_seq.start(p_sequencer.apb_seqr);

    // 2. Send that data out via UART
    uart_seq.start(p_sequencer.uart_seqr);
  endtask
endclass

----------------------------------------------------
ðŸ”— 4ï¸âƒ£ Connecting Everything (Virtual Sequencer Example)

class virtual_sequencer extends uvm_sequencer;
  `uvm_component_utils(virtual_sequencer)

  // Handles to sub-sequencers
  apb_sequencer  apb_seqr;
  uart_sequencer uart_seqr;

  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction
endclass


Then your **env** connects it:
function void connect_phase(uvm_phase phase);
  vseqr.apb_seqr  = apb_agent.seqr;
  vseqr.uart_seqr = uart_agent.seqr;
endfunction

Now the virtual sequence can access all agentsâ€™ sequencers through `p_sequencer`.

---------------------------------------------

âš™ï¸ 5ï¸âƒ£ Why Layered Sequences Are Useful

| Benefit         | Explanation                                                                                          |
| --------------- | ---------------------------------------------------------------------------------------------------- |
| **Scalability** | You can control multiple agents together in one test.                                                |
| **Reuse**       | Each sub-sequence (APB, UART, FIFO) can be reused in isolation or as part of a bigger system.        |
| **Abstraction** | The virtual sequence hides protocol details â€” the top test only sees â€œsend packetâ€ or â€œinit memory.â€ |
| **Flexibility** | Easy to add new protocols (just plug in another agent).                                              |

--------------------------------------------------

## ðŸ§  6ï¸âƒ£ Real-World Analogy

Imagine a company:

* **APB Agent** â†’ Finance department
* **UART Agent** â†’ Shipping department
* **FIFO Agent** â†’ Storage team
* **Virtual Sequencer** â†’ The manager connecting them all
* **Virtual Sequence** â†’ The managerâ€™s plan (â€œShip order after payment!â€)

Each sub-sequence works independently, but the virtual sequence coordinates the order.

----------------------------------------------------

## ðŸ§˜ 7ï¸âƒ£ Summary for Beginners

| Concept               | You Need toâ€¦                                             |
| --------------------- | -------------------------------------------------------- |
| **Virtual Sequencer** | Understand it holds references to other sequencers.      |
| **Virtual Sequence**  | Know it coordinates multiple sequences across agents.    |
| **When to Use**       | Only when your testbench has multiple interfaces/agents. |
| **When to Skip**      | For single-agent benches (Counter, MUX, UART alone).     |

----------------------------------------------------

ðŸ’¬ Key Takeaway

> Virtual sequences let you coordinate **multiple independent agents**
> from one centralized test â€” essential for **SoC-level verification**,
> but not required for **simple module-level** DV work.

----------------------------------------------------
