# ğŸ§© UVM End Phases

ğŸ¬ 1. What Are End Phases?
After `run_phase` (where the simulation actually runs and time moves), UVM automatically enters **end phases** to:
* Collect results ğŸ“Š
* Perform final checks âœ…
* Print a summary ğŸ§¾

They ensure that your test completes cleanly, with all data gathered and results clearly reported.

----------------------------------------------------------

âš™ï¸ 2. Why Do We Need Them?
When your simulation finishes, you want to know:
* What happened during the test?
* Did the DUT behave correctly?
* Are there any errors or coverage gaps?

End phases exist to **summarize and finalize** everything â€” like a closing report at the end of the workday.

----------------------------------------------------------

ğŸ§± 3. The Three Main End Phases

| Phase             | Purpose                        | What You Typically Do                            |
| ----------------- | ------------------------------ | ------------------------------------------------ |
| **extract_phase** | Collect results and statistics | Gather scoreboard data, coverage, counters       |
| **check_phase**   | Decide pass/fail               | Analyze collected results and verify correctness |
| **report_phase**  | Print summary                  | Display final simulation report and status       |

---

Letâ€™s go through them one by one ğŸ‘‡

ğŸ”¹ (1) extract_phase â€” *Collect results*
This is where all verification components (like scoreboard, monitor, coverage collector) **submit their final data**.

You gather:
* Number of transactions
* Errors or mismatches
* Coverage data

ğŸ’¡ Analogy: Everyone in the company sends their end-of-day report to the manager.

ğŸ§± Example:

function void extract_phase(uvm_phase phase);
  super.extract_phase(phase);
  num_errors = scoreboard.get_error_count();
  num_txns   = monitor.get_txn_count();
endfunction


âœ…extract_phase = â€œCollect all test results and metrics.â€

---

ğŸ”¹ (2) check_phase â€” *Final validation*
Now that all results are collected, you **check** if the DUT passed or failed.

You might:
* Compare expected vs actual data
* Check that error count = 0
* Verify functional coverage goals

ğŸ’¡ Analogy: The manager reviews all the reports and decides: â€œWas today successful or not?â€

ğŸ§± Example:
function void check_phase(uvm_phase phase);
  super.check_phase(phase);
  if (num_errors == 0)
    `uvm_info("CHECK", "All tests passed âœ…", UVM_LOW)
  else
    `uvm_error("CHECK", $sformatf("%0d errors found âŒ", num_errors))
endfunction


âœ… check_phase = â€œJudge if the test passed or failed.â€

---
ğŸ”¹ (3) report_phase â€” *Print summary*
This is the **final** phase. UVM prints:
* Test summary
* Error and warning counts
* Custom messages you define

This is what appears at the end of your simulation log.

ğŸ’¡ Analogy: At the end of the day, the manager gives a short presentation: â€œHereâ€™s todayâ€™s summary: 0 errors, all tests passed!â€

ğŸ§± Example:
function void report_phase(uvm_phase phase);
  super.report_phase(phase);
  `uvm_info("REPORT", "Simulation completed successfully ğŸ‰", UVM_NONE)
endfunction

âœ… report_phase = â€œPrint the final summary.â€

----------------------------------------------------------

ğŸ‘€ 4. Two Useful Visual Phases

These two phases donâ€™t belong to the end phases, but theyâ€™re great for debugging and visualization. They occur *before* time starts moving.

| Phase                         | When It Happens                 | Purpose                                                   |
| ----------------------------- | ------------------------------- | --------------------------------------------------------- |
| **end_of_elaboration_phase**  | After build/connect, before run | Hierarchy is fully built â€” you can print topology         |
| **start_of_simulation_phase** | Just before run_phase           | Final tweaks, banners, and setup before simulation begins |


ğŸ§± Example:
function void end_of_elaboration_phase(uvm_phase phase);
  super.end_of_elaboration_phase(phase);
  uvm_top.print_topology(); // Prints testbench structure
endfunction

function void start_of_simulation_phase(uvm_phase phase);
  super.start_of_simulation_phase(phase);
  `uvm_info("SIM", "Starting simulation...", UVM_NONE)
endfunction


âœ… **In short:**
* **end_of_elaboration_phase:** Print component hierarchy.
* **start_of_simulation_phase:** Final log banners and tweaks before time starts.

----------------------------------------------------------
ğŸ§  5. Complete Simulation Flow (Big Picture)

1ï¸âƒ£ build_phase              â†’ Create components
2ï¸âƒ£ connect_phase            â†’ Connect components
3ï¸âƒ£ end_of_elaboration_phase â†’ Print topology (optional)
4ï¸âƒ£ start_of_simulation_phase â†’ Prepare to run
5ï¸âƒ£ run_phase                â†’ Time-based simulation
6ï¸âƒ£ extract_phase            â†’ Collect results
7ï¸âƒ£ check_phase              â†’ Validate results
8ï¸âƒ£ report_phase             â†’ Print final summary

âœ… The last three (extract, check, report) are the **end phases** â€” they finalize and summarize your test.

----------------------------------------------------------

ğŸ§© **In simple terms:** `End Phases = The cleanup, checking, and reporting stages after your test finishes running.`

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
