üß© UVM Factory, Macros & Objections ‚Äî Beginner Friendly Explanation

üè≠ Part 1: UVM Factory & Overrides
üß† What is the UVM Factory?
The **UVM Factory** is a smart mechanism that controls how objects and components are created in your testbench. 
Instead of using `new()` everywhere, you use the **factory** to create them dynamically.

Why? Because you can later replace (override) those classes *without editing any environment code.*

my_driver drv;
function void build_phase(uvm_phase phase);
  super.build_phase(phase);
  drv = my_driver::type_id::create("drv", this);
endfunction

‚úÖ The factory creates `my_driver`, or an overridden version if one exists.

---

üîπ Type Override (Global Replacement)
Replace **every** creation of a class type globally.

factory.set_type_override_by_type(my_driver::get_type(), my_driver_cov::get_type(), 1);


* If your environment creates `my_driver`, the factory actually builds `my_driver_cov`.
* Effect is **global** ‚Äî applies to all instances.

üß† **Analogy:** Telling the factory, ‚ÄúFrom now on, build all cars as the *electric model*, not the regular one.‚Äù

---

üîπ Instance Override (Local Replacement)
Replace only **one particular instance** in the hierarchy.

factory.set_inst_override_by_name("my_driver", "my_driver_cov", "uvm_test_top.env.agt.drv");


* Affects only the component at that exact hierarchical path.
* Other instances remain unchanged.

üß† **Analogy:** ‚ÄúUpgrade only John‚Äôs car to electric, keep others normal.‚Äù

---

### üß± Comparison Table

| Type                  | Scope    | Function                      | Example             | Use Case                                |
| --------------------- | -------- | ----------------------------- | ------------------- | --------------------------------------- |
| **Type Override**     | Global   | `set_type_override_by_type()` | Replace all drivers | All testbench drivers use a new version |
| **Instance Override** | Specific | `set_inst_override_by_name()` | Replace one driver  | Only one instance gets replaced         |

‚úÖ Always set overrides **before** components are created (in `build_phase`).

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

‚öôÔ∏è Part 2: UVM Macros (Factory + Reporting)

üß© 1. `uvm_object_utils(TYPE)`
Registers **non-component classes** (no hierarchy, no phases) with the factory ‚Äî e.g., sequence items, config objects.

class pkt extends uvm_sequence_item;
  rand bit [7:0] addr, data;
  `uvm_object_utils(pkt)
  function new(string name="pkt"); super.new(name); endfunction
endclass

* Enables creation via `pkt::type_id::create("tr");`
* Allows factory overrides and optional field automation.

---

### üß© 2. `uvm_component_utils(TYPE)`

Registers **component classes** (have hierarchy & phases) with the factory ‚Äî e.g., drivers, monitors, agents, env, tests.

class my_driver extends uvm_driver#(pkt);
  `uvm_component_utils(my_driver)
  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction
endclass

‚úÖ Components use `(name, parent)` because they belong in a hierarchical structure.

---

üß© 3. `uvm_do(...)` Family (Legacy Shorthand)

Simplifies common sequence flow (`create ‚Üí start ‚Üí randomize ‚Üí finish`).

`uvm_do(tr)
// expands to:
tr = pkt::type_id::create("tr");
start_item(tr);
assert(tr.randomize());
finish_item(tr);

With constraints:
`uvm_do_with(tr, { addr==8'hA5; data inside {[1:10]}; })

‚úÖ Handy shortcut, but prefer the **explicit style** for readability.

---

üß© 4. Reporting Macros

| Macro                          | Meaning               | Simulation Continues? | Notes                           |
| ------------------------------ | --------------------- | --------------------- | ------------------------------- |
| `uvm_info(ID, MSG, VERBOSITY)` | Informational message | ‚úÖ Yes                 | Shown if verbosity level allows |
| `uvm_warning(ID, MSG)`         | Warning               | ‚úÖ Yes                 | Caution but non-fatal           |
| `uvm_error(ID, MSG)`           | Error                 | ‚úÖ Yes                 | Increments error counter        |
| `uvm_fatal(ID, MSG)`           | Fatal                 | ‚ùå No                  | Stops simulation immediately    |

**Example:**

`uvm_info   ("DRV",  $sformatf("Driving addr=0x%0h data=0x%0h", tr.addr, tr.data), UVM_MEDIUM)
`uvm_warning("TIMING", "Late handshake observed")
`uvm_error  ("PROT",  "Protocol violation detected")
`uvm_fatal  ("CFG",   "Missing virtual interface")

---

üîπ Controlling Verbosity

Set globally on command line:
+UVM_VERBOSITY=UVM_MEDIUM

Or dynamically in code:

uvm_top.set_report_verbosity_level(UVM_HIGH);

| Level        | Description                     |
| ------------ | ------------------------------- |
| `UVM_LOW`    | Always visible (key milestones) |
| `UVM_MEDIUM` | Normal debug (default)          |
| `UVM_HIGH`   | Detailed debug info             |
| `UVM_FULL`   | Extremely detailed logging      |
| `UVM_NONE`   | No info messages                |

üß† **Tip:** Use `UVM_LOW` for milestones, `UVM_MEDIUM` for normal runs, and `UVM_HIGH/FULL` for deep debugging.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

üé¨ Part 3: UVM Objections

üß† Why Do We Need Objections?
In a plain testbench, you‚Äôd use `$finish` to end simulation. But UVM has multiple components (test, driver, monitor, scoreboard, etc.) ‚Äî so we need a **coordinated way** to know when everyone‚Äôs done.

‚úÖ **Objections** let components say:
> ‚ÄúI‚Äôm still working, don‚Äôt end yet!‚Äù ‚Üí `raise_objection(this)`

and later:
> ‚ÄúI‚Äôm done, you can end now.‚Äù ‚Üí `drop_objection(this)`

Simulation ends **only when all objections are dropped.**

üß± Example

task run_phase(uvm_phase phase);
  phase.raise_objection(this);
  `uvm_info("TEST", "Starting sequence...", UVM_LOW)

  seq.start(env.agt.seqr);

  `uvm_info("TEST", "Test complete, dropping objection.", UVM_LOW)
  phase.drop_objection(this);
endtask


üß† What Happens

1Ô∏è‚É£ `raise_objection(this)` ‚Üí simulation stays alive.
2Ô∏è‚É£ Your sequences and transactions run.
3Ô∏è‚É£ `drop_objection(this)` ‚Üí simulation can end once everyone‚Äôs done.

If you forget to drop ‚Üí simulation **never ends!**

---

üß© Visual Analogy

Time ‚Üí ------------------------>
Driver:     raise----run------drop
Monitor:          raise---run---drop
Scoreboard:            raise----drop
-------------------------------------
Simulation ends only after all drops ‚úÖ


üí° Real-World Analogy

In a group project:
* Each student raises their hand ‚úã when still speaking.
* Simulation (teacher) waits until everyone lowers their hand.
* When all hands are down ‚Üí class dismissed üéì

---

### ‚úÖ Key Rules

| Function                      | Meaning                             |
| ----------------------------- | ----------------------------------- |
| `phase.raise_objection(this)` | Tell UVM: ‚ÄúKeep simulation running‚Äù |
| `phase.drop_objection(this)`  | Tell UVM: ‚ÄúI‚Äôm done, you may end‚Äù   |
| Who uses it                   | Any component or sequence           |
| When does sim end             | When all objections are dropped     |


## üßò Recap Table

| Concept               | Description                                                   | Analogy                                           |
| --------------------- | ------------------------------------------------------------- | ------------------------------------------------- |
| **Factory Overrides** | Dynamically replace one class with another                    | Reprogramming what the factory builds             |
| **Macros**            | Shortcuts for factory registration, transactions, and logging | Handy templates or buttons for common patterns    |
| **Reporting Macros**  | Structured debug messages                                     | Dashboard lights showing INFO/WARNING/ERROR/FATAL |
| **Objections**        | Mechanism to end simulation only when all are done            | Group project: class ends when all hands down     |

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

üìò **In simple terms:**
**Factory** decides *what* to create,
**Macros** define *how* you register, build, and report,
**Objections** decide *when* to stop simulation.
